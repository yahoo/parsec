{
    "docs": [
        {
            "location": "/", 
            "text": "Parsec introduction\n\n\nCurrent Version: \n0.0.14-pre\n\n\nParsec is a collection of libraries and utilities built on Maven and\nJersey2. It is designed to reduce the effort of building web service\napplications, allowing you to spend more quality time elsewhere. By\nusing Parsec, the grunt work is handled so you can concentrate on the\nlogic and implementation side of development.\n\n\nParsec offers a standardized end-to-end solution to quickly bring web\nservice applications from concept to production. The goal of Parsec is\nto:\n\n\n\n\nProvide a standard method for building RESTFul APIs\n\n\nEliminate time spent in project and environment set up\n\n\nMinimize time and effort spent on common repetitive tasks\n\n\nProvide helper libraries and utilities for common tasks\n\n\nReduce the learning curve and maintenance cost\n\n\n\n\nIf you are building a new project with Java, Parsec is a good starting\npoint. See the \nGetting Started\n section to get started\nquickly.", 
            "title": "Home"
        }, 
        {
            "location": "/#parsec-introduction", 
            "text": "Current Version:  0.0.14-pre  Parsec is a collection of libraries and utilities built on Maven and\nJersey2. It is designed to reduce the effort of building web service\napplications, allowing you to spend more quality time elsewhere. By\nusing Parsec, the grunt work is handled so you can concentrate on the\nlogic and implementation side of development.  Parsec offers a standardized end-to-end solution to quickly bring web\nservice applications from concept to production. The goal of Parsec is\nto:   Provide a standard method for building RESTFul APIs  Eliminate time spent in project and environment set up  Minimize time and effort spent on common repetitive tasks  Provide helper libraries and utilities for common tasks  Reduce the learning curve and maintenance cost   If you are building a new project with Java, Parsec is a good starting\npoint. See the  Getting Started  section to get started\nquickly.", 
            "title": "Parsec introduction"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Getting Started\n\n\nRequirements\n\n\n\n\nJava 1.8\n: check your jdk version using \n$ java -version\n or \ndownload Java JDK 1.8\n\n\nGradle (recommended version: \n2.4)\n: check your gradle version using \n$ gradle --v\n or run\n\n\n\n\n$ sudo brew install gradle\n to install the latest gradle\n\n\nAfter having Java 1.8 and Gradle installed with the proper version, you must do a one time setup to allow you to create a\nParsec project without a build.gradle script.\n\n\n$ vim ~/.gradle/init.gradle\n, then enter the following code:\n\n\ngradle.beforeProject { prj -\n\n   prj.apply from: 'https://raw.githubusercontent.com/yahoo/parsec/master/parsec-template-plugin/installation/apply.groovy'\n}\n\n\n\n\n\nCreate a New Project\n\n\nTo create a new Parsec project, run:\n\n\n$ gradle createParsecProject -PgroupId='your.group.name' -PartifactId='your_project_name'\n\n\ngroupId\n refers to the namespace of your package, while the \nartifactId\n is your project name.\nIf you do not specify the groupId or artifactId, you will be prompted to do so.\n\n\nCreate Schema\n\n\nYou need one or more RDL schema files to define your API specifications; they should be placed under src/main/rdl/ and be named as *.rdl.\nRDL is a machine-readable description of a schema that describes data types, as well as resources using those types.\n\n\nYou can start with this sample RDL file, save it as src/main/rdl/sample.rdl:\n\n\nnamespace your.group.name;\nname sample;\nversion 1;\n\ntype User struct {\n    string name (x_not_null=\ngroups=insert\n, x_size=\nmin=3,max=5,groups=update|insert\n);\n    string occupation (x_not_null=\ngroups=update\n, x_size=\nmin=4,groups=update|insert\n);\n    int32 age;\n    string id (x_null=\ngroups=insert\n);\n}\n\nresource User GET \n/users/{id}\n {\n    int32 id;\n\n    expected OK;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        ResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n}\n\nresource string POST \n/users\n {\n    User user (x_must_validate=\ninsert\n);\n\n    expected OK;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        ResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n}\n\nresource string PUT \n/users/{id}\n {\n    int32 id ;\n\n    User user (x_must_validate=\nupdate\n);\n\n    expected OK;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        ResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n\n}\n\n\n\n\nGenerate Code\n\n\nAfter you have added your rdl files in the folder, you can use the command below to generate files:\n\n\n$ gradle parsec-generate\n\n\nHere is an example of the generated folder structure, based on the sample.rdl above:\n\n\n$ tree build/generated-sources/\nbuild/generated-sources/\n\u2514\u2500\u2500 java\n    \u2514\u2500\u2500 your\n        \u2514\u2500\u2500group\n            \u2514\u2500\u2500name\n                \u2514\u2500\u2500parsec_generated\n                    \u251c\u2500\u2500 ParsecApplication.java\n                    \u251c\u2500\u2500 ParsecErrorBody.java\n                    \u251c\u2500\u2500 ParsecErrorDetail.java\n                    \u251c\u2500\u2500 ParsecExceptionMapper.java\n                    \u251c\u2500\u2500 ParsecResourceError.java\n                    \u251c\u2500\u2500 ParsecValidationGroups.java\n                    \u251c\u2500\u2500 ParsecWebListener.java\n                    \u251c\u2500\u2500 ParsecWrapperServlet.java\n                    \u251c\u2500\u2500 ResourceContext.java\n                    \u251c\u2500\u2500 ResourceError.java\n                    \u251c\u2500\u2500 ResourceException.java\n                    \u251c\u2500\u2500 SampleHandler.java\n                    \u251c\u2500\u2500 SampleResources.java\n                    \u251c\u2500\u2500 SampleServer.java\n                    \u2514\u2500\u2500 User.java\n\n4 directories, 15 files\n\n$ tree src/main/java/\nsrc/main/java/\n\u2514\u2500\u2500 your\n    \u2514\u2500\u2500 group\n        \u2514\u2500\u2500name\n            \u251c\u2500\u2500 DefaultApplication.java\n            \u251c\u2500\u2500 DefaultExceptionMapper.java\n            \u251c\u2500\u2500 DefaultResourceContext.java\n            \u251c\u2500\u2500 DefaultWebListener.java\n            \u251c\u2500\u2500 SampleClient.java\n            \u251c\u2500\u2500 SampleClientImpl.java\n            \u2514\u2500\u2500 SampleHandlerImpl.java\n\n2 directories, 7 files\n\n\n\n\nParsec generated Java server, model code, and Java client for the server. The generated code would include:\n\n\n\n\nJava models / data objects, for example: User.java\n\n\nJersey resource endpoints, for example: SampleResource.java\n\n\nHandler interfaces, for example: SampleHandler.java - Handler implementations follow a naming convention: \nHandlerImpl.java\n\n\nJava client for your web service, for example: SampleClient.java, SampleClientImpl.java\n\n\n\n\nJava files are generated under ${baseDir}/build/generated-sources/java and the generated Java code are in sub-package \n.parsec_generated\n\n\nImplement Handlers\n\n\nNow you can start to implement your API by editing *HandlerImpl.java files. Here is an example of SampleHandlerImpl.java:\n\n\npackage your.group.name;\n\nimport your.group.name.parsec_generated.User;\nimport your.group.name.parsec_generated.SampleHandler;\nimport your.group.name.parsec_generated.ResourceContext;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * SampleHandlerImpl is interface implementation that implement SampleHandler interface.\n */\npublic class SampleHandlerImpl implements SampleHandler {\n\n    @Override\n    public User getUsersById(ResourceContext context, Integer id) {\n        User user = new User();\n        user.setName(\nuser\n);\n        return user;\n    }\n\n    @Override\n    public String postUsers(ResourceContext context, User user) {\n        return \nPost to user \n + user.getName() + \n!\\n\n;\n    }\n\n    @Override\n    public String putUsersById(ResourceContext context, Integer id, User user) {\n        return \nput to user \n + user.getName() + \n by id \n + id + \n!\\n\n;\n    }\n\n    @Override\n    public ResourceContext newResourceContext(HttpServletRequest request, HttpServletResponse response) {\n        return new DefaultResourceContext(request, response);\n    }\n}\n\n\n\n\nStart your Server\n\n\nNow you can start your server with:\n\n\n$ gradle jettyRun\n\n\nCheck out your \nSwagger dashboard\n\n\nNow you can run test with:\n\n\n$ curl http://localhost:8080/api/sample/v1/users/1\n\n{\nage\n:0,\nname\n:\nuser\n}\n\n$ curl -H 'Content-Type: application/json' -d '{\nname\n:\nuser\n,\nage\n:10}' http://localhost:8080/api/sample/v1/users\n\nWelcome to Parsec, user!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/quickstart/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/quickstart/#requirements", 
            "text": "Java 1.8 : check your jdk version using  $ java -version  or  download Java JDK 1.8  Gradle (recommended version:  2.4) : check your gradle version using  $ gradle --v  or run   $ sudo brew install gradle  to install the latest gradle  After having Java 1.8 and Gradle installed with the proper version, you must do a one time setup to allow you to create a\nParsec project without a build.gradle script.  $ vim ~/.gradle/init.gradle , then enter the following code:  gradle.beforeProject { prj - \n   prj.apply from: 'https://raw.githubusercontent.com/yahoo/parsec/master/parsec-template-plugin/installation/apply.groovy'\n}", 
            "title": "Requirements"
        }, 
        {
            "location": "/quickstart/#create-a-new-project", 
            "text": "To create a new Parsec project, run:  $ gradle createParsecProject -PgroupId='your.group.name' -PartifactId='your_project_name'  groupId  refers to the namespace of your package, while the  artifactId  is your project name.\nIf you do not specify the groupId or artifactId, you will be prompted to do so.", 
            "title": "Create a New Project"
        }, 
        {
            "location": "/quickstart/#create-schema", 
            "text": "You need one or more RDL schema files to define your API specifications; they should be placed under src/main/rdl/ and be named as *.rdl.\nRDL is a machine-readable description of a schema that describes data types, as well as resources using those types.  You can start with this sample RDL file, save it as src/main/rdl/sample.rdl:  namespace your.group.name;\nname sample;\nversion 1;\n\ntype User struct {\n    string name (x_not_null= groups=insert , x_size= min=3,max=5,groups=update|insert );\n    string occupation (x_not_null= groups=update , x_size= min=4,groups=update|insert );\n    int32 age;\n    string id (x_null= groups=insert );\n}\n\nresource User GET  /users/{id}  {\n    int32 id;\n\n    expected OK;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        ResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n}\n\nresource string POST  /users  {\n    User user (x_must_validate= insert );\n\n    expected OK;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        ResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n}\n\nresource string PUT  /users/{id}  {\n    int32 id ;\n\n    User user (x_must_validate= update );\n\n    expected OK;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        ResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n\n}", 
            "title": "Create Schema"
        }, 
        {
            "location": "/quickstart/#generate-code", 
            "text": "After you have added your rdl files in the folder, you can use the command below to generate files:  $ gradle parsec-generate  Here is an example of the generated folder structure, based on the sample.rdl above:  $ tree build/generated-sources/\nbuild/generated-sources/\n\u2514\u2500\u2500 java\n    \u2514\u2500\u2500 your\n        \u2514\u2500\u2500group\n            \u2514\u2500\u2500name\n                \u2514\u2500\u2500parsec_generated\n                    \u251c\u2500\u2500 ParsecApplication.java\n                    \u251c\u2500\u2500 ParsecErrorBody.java\n                    \u251c\u2500\u2500 ParsecErrorDetail.java\n                    \u251c\u2500\u2500 ParsecExceptionMapper.java\n                    \u251c\u2500\u2500 ParsecResourceError.java\n                    \u251c\u2500\u2500 ParsecValidationGroups.java\n                    \u251c\u2500\u2500 ParsecWebListener.java\n                    \u251c\u2500\u2500 ParsecWrapperServlet.java\n                    \u251c\u2500\u2500 ResourceContext.java\n                    \u251c\u2500\u2500 ResourceError.java\n                    \u251c\u2500\u2500 ResourceException.java\n                    \u251c\u2500\u2500 SampleHandler.java\n                    \u251c\u2500\u2500 SampleResources.java\n                    \u251c\u2500\u2500 SampleServer.java\n                    \u2514\u2500\u2500 User.java\n\n4 directories, 15 files\n\n$ tree src/main/java/\nsrc/main/java/\n\u2514\u2500\u2500 your\n    \u2514\u2500\u2500 group\n        \u2514\u2500\u2500name\n            \u251c\u2500\u2500 DefaultApplication.java\n            \u251c\u2500\u2500 DefaultExceptionMapper.java\n            \u251c\u2500\u2500 DefaultResourceContext.java\n            \u251c\u2500\u2500 DefaultWebListener.java\n            \u251c\u2500\u2500 SampleClient.java\n            \u251c\u2500\u2500 SampleClientImpl.java\n            \u2514\u2500\u2500 SampleHandlerImpl.java\n\n2 directories, 7 files  Parsec generated Java server, model code, and Java client for the server. The generated code would include:   Java models / data objects, for example: User.java  Jersey resource endpoints, for example: SampleResource.java  Handler interfaces, for example: SampleHandler.java - Handler implementations follow a naming convention:  HandlerImpl.java  Java client for your web service, for example: SampleClient.java, SampleClientImpl.java   Java files are generated under ${baseDir}/build/generated-sources/java and the generated Java code are in sub-package  .parsec_generated", 
            "title": "Generate Code"
        }, 
        {
            "location": "/quickstart/#implement-handlers", 
            "text": "Now you can start to implement your API by editing *HandlerImpl.java files. Here is an example of SampleHandlerImpl.java:  package your.group.name;\n\nimport your.group.name.parsec_generated.User;\nimport your.group.name.parsec_generated.SampleHandler;\nimport your.group.name.parsec_generated.ResourceContext;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * SampleHandlerImpl is interface implementation that implement SampleHandler interface.\n */\npublic class SampleHandlerImpl implements SampleHandler {\n\n    @Override\n    public User getUsersById(ResourceContext context, Integer id) {\n        User user = new User();\n        user.setName( user );\n        return user;\n    }\n\n    @Override\n    public String postUsers(ResourceContext context, User user) {\n        return  Post to user   + user.getName() +  !\\n ;\n    }\n\n    @Override\n    public String putUsersById(ResourceContext context, Integer id, User user) {\n        return  put to user   + user.getName() +   by id   + id +  !\\n ;\n    }\n\n    @Override\n    public ResourceContext newResourceContext(HttpServletRequest request, HttpServletResponse response) {\n        return new DefaultResourceContext(request, response);\n    }\n}", 
            "title": "Implement Handlers"
        }, 
        {
            "location": "/quickstart/#start-your-server", 
            "text": "Now you can start your server with:  $ gradle jettyRun  Check out your  Swagger dashboard  Now you can run test with:  $ curl http://localhost:8080/api/sample/v1/users/1\n\n{ age :0, name : user }\n\n$ curl -H 'Content-Type: application/json' -d '{ name : user , age :10}' http://localhost:8080/api/sample/v1/users\n\nWelcome to Parsec, user!", 
            "title": "Start your Server"
        }, 
        {
            "location": "/main/", 
            "text": "Main Components\n\n\nRDL and Parsec RDL Generator\n\n\n\n\nRDL\n\n\nIs a description language for specifying an HTTP-based web\n    service.\n\n\nArdielle(RDL) official site: \nhttps://ardielle.github.io\n\n\n\n\n\n\nParsec RDL Generator\n\n\nGenerates data objects, Jersey endpoints, interfaces, and stubs.\n\n\nGenerates Swagger JSON for Swagger UI\n\n\nGenerates Markdown and JSON for documentations\n\n\n\n\n\n\n\n\nParsec Template Plugin\n\n\nParsec Template Plugin is a gradle plugin extended from townsfolk's \ngradle templates plugin\n.\nIt provides similar functionality as Maven's archetype, which generates files and directories based on a template. In parsec templates plugin, a custom template is provided which is tailored\nfor Parsec. See the default output for a sample of what the folder structures will look like.\n\n\nPlease refer to \nParsec Template Plugin Doc\n for details\n\n\nParsec Base Build\n\n\nThe base build provides a parent \nparsec.gradle\n\nfile for any Parsec project to inherit from. The build file includes\ndependencies, build plugins, and necessary configurations that are used within a Parsec project. These external settings\nare designed to enforce a standardized build process in which enhances the quality of the Parsec client's application.\nIt also includes the Parsec Gradle Plugin which is responsible for parsing the RDLs and generating files.\n\n\nUsage\n\n\nThe base build is essentially a Script Plugin and must be inherited using:\n\n\napply from: 'https://raw.githubusercontent.com/yahoo/parsec/master/parsec-base-build/src/main/resources/parsec.gradle'\n\n\n\n\nThe parsec.gradle file includes all necessary dependencies for you to get started with a Parsec project.\n\n\nProperties\n\n\nTo override properties (eg. version numbers), create identically-named properties within your project. There are multiple\nways of doing this, the easiest and recommended way is to add in the properties in your project's \ngradle.properties\n file. Once you have\ndefine the properties, it will take precedence over the properties defined by the base build. Optionally, you could also define\nthe properties in your \nbuildscript { }\n block. \n\n\nYou can view the defined properties \nhere.\n\n\nParsec Gradle Plugin\n\n\nParsec Gradle Plugin is the underlying core of Parsec which utilizes the RDL generator. \nIts main purpose is to generate all the necessary files, based on the given RDL schema, in order to get a webservice started.\n\n\nInstallation\n\n\nIn your build script, add in the buildscript dependencies needed in order\nto apply the plugin:\n\n\nbuildscript{\n    repositories{\n        jcenter()\n    }\n    dependencies{\n        classpath group: 'com.yahoo.parsec'  , name: 'parsec-gradle-plugin'   , version : '0.0.14-pre'\n    }\n}\n\n\n\n\nthen you can \napply plugin: 'com.yahoo.parsec.gradle-plugin'\n\n\nUsage\n\n\nIf used in conjunction with the Parsec Template Plugin (ie. after running \n$ gradle createParsecProject\n), you can simply\nput the RDL files inside \"src/main/rdl\". If not, you must specify the RDL sourcePath inside the configuration.\n\n\nTo generate the files after providing the rdl schema, use \n$ gradle parsec-generate\n\n\nPlease refer to \nParsec Gradle Plugin Doc\n for details.", 
            "title": "Main Components"
        }, 
        {
            "location": "/main/#main-components", 
            "text": "", 
            "title": "Main Components"
        }, 
        {
            "location": "/main/#rdl-and-parsec-rdl-generator", 
            "text": "RDL  Is a description language for specifying an HTTP-based web\n    service.  Ardielle(RDL) official site:  https://ardielle.github.io    Parsec RDL Generator  Generates data objects, Jersey endpoints, interfaces, and stubs.  Generates Swagger JSON for Swagger UI  Generates Markdown and JSON for documentations", 
            "title": "RDL and Parsec RDL Generator"
        }, 
        {
            "location": "/main/#parsec-template-plugin", 
            "text": "Parsec Template Plugin is a gradle plugin extended from townsfolk's  gradle templates plugin .\nIt provides similar functionality as Maven's archetype, which generates files and directories based on a template. In parsec templates plugin, a custom template is provided which is tailored\nfor Parsec. See the default output for a sample of what the folder structures will look like.  Please refer to  Parsec Template Plugin Doc  for details", 
            "title": "Parsec Template Plugin"
        }, 
        {
            "location": "/main/#parsec-base-build", 
            "text": "The base build provides a parent  parsec.gradle \nfile for any Parsec project to inherit from. The build file includes\ndependencies, build plugins, and necessary configurations that are used within a Parsec project. These external settings\nare designed to enforce a standardized build process in which enhances the quality of the Parsec client's application.\nIt also includes the Parsec Gradle Plugin which is responsible for parsing the RDLs and generating files.", 
            "title": "Parsec Base Build"
        }, 
        {
            "location": "/main/#usage", 
            "text": "The base build is essentially a Script Plugin and must be inherited using:  apply from: 'https://raw.githubusercontent.com/yahoo/parsec/master/parsec-base-build/src/main/resources/parsec.gradle'  The parsec.gradle file includes all necessary dependencies for you to get started with a Parsec project.", 
            "title": "Usage"
        }, 
        {
            "location": "/main/#properties", 
            "text": "To override properties (eg. version numbers), create identically-named properties within your project. There are multiple\nways of doing this, the easiest and recommended way is to add in the properties in your project's  gradle.properties  file. Once you have\ndefine the properties, it will take precedence over the properties defined by the base build. Optionally, you could also define\nthe properties in your  buildscript { }  block.   You can view the defined properties  here.", 
            "title": "Properties"
        }, 
        {
            "location": "/main/#parsec-gradle-plugin", 
            "text": "Parsec Gradle Plugin is the underlying core of Parsec which utilizes the RDL generator. \nIts main purpose is to generate all the necessary files, based on the given RDL schema, in order to get a webservice started.", 
            "title": "Parsec Gradle Plugin"
        }, 
        {
            "location": "/main/#installation", 
            "text": "In your build script, add in the buildscript dependencies needed in order\nto apply the plugin:  buildscript{\n    repositories{\n        jcenter()\n    }\n    dependencies{\n        classpath group: 'com.yahoo.parsec'  , name: 'parsec-gradle-plugin'   , version : '0.0.14-pre'\n    }\n}  then you can  apply plugin: 'com.yahoo.parsec.gradle-plugin'", 
            "title": "Installation"
        }, 
        {
            "location": "/main/#usage_1", 
            "text": "If used in conjunction with the Parsec Template Plugin (ie. after running  $ gradle createParsecProject ), you can simply\nput the RDL files inside \"src/main/rdl\". If not, you must specify the RDL sourcePath inside the configuration.  To generate the files after providing the rdl schema, use  $ gradle parsec-generate  Please refer to  Parsec Gradle Plugin Doc  for details.", 
            "title": "Usage"
        }, 
        {
            "location": "/util/", 
            "text": "Supporting Libraries and Utilities\n\n\nInput Validation\n\n\nPurpose\n\n\n\n\n\n\nDefine standard method for input validation in Parsec Java web\n    applications\n\n\nSupport web applications\u2019 requirement to validate user input\n    depending on their business logic\n\n\n\n\n\n\nDesign and implementation\n\n\n\n\n\n\nAdopt \nbean validation in\n    Jersey\n,\n    which is Jersey framework\u2019s native feature\n\n\nJersey bean validation depends directly on Hibernate Validator, it\n    supports validating all forms of input from Jersey framework. Such\n    as @PathParam, @QueryParam, @FormParam, and request body json\n    object by declaring hibernate validation annotations (such as\n    @Size, @Null, @NotNull, \u2026) (\nsection builtin constraints\n    doc\n)\n\n\nparsec_validation Java package\n\n\nrequires jersey-bean-validation dependency\n\n\nparsec_validation added to dependency by default if project\n    inherits \nParsec Base\n    Build\n\n\nwhen parsec_validation is added to dependency (in build.gradle),\n    validation feature will be enabled automatically without\n    requiring any additional function calls\n\n\nImplemented ParsecValidationExceptionMapper to catch\n    ConstraintViolationException exception (which is thrown by\n    Hibernate Validator)\n\n\n\n\n\n\nUser can also customize their validation exception {code},\n    {message} by defining server properties in DefaultWebListener.java\n\n\nParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_CODE\n\n\nParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_MSG\n\n\n\n\n\n\nImplemented ParsecValidationAutoDiscoverable to register higher\n    priority for ParsecConstraintViolationExceptionMapper (because the\n    default priority of Jersey's ConstraintViolationExceptionMapper\n    for ConstraintViolationException is higher than others)\n\n\nIntegrate hibernate validation annotation with Parsec RDL\n    Generator (see \nRDL + Parsec RDL\n    Generator\n)\n\n\ndefine hibernate validation annotation in .rdl then the\n    annotations will be generated\n\n\n\n\n\n\nValidation\n    github\n\n\n\n\n\n\ndefault build.gradle snippet:\n\n\ndependencies {\n    //...\n    compile group: 'com.yahoo.parsec', name: 'parsec-validation', version: '0.0.15'\n    //...\n}\n\n\n\n\nerror layout example:\n\n\n{\n    \nerror\n:{\n        \ndetail\n:[\n            {\n                \nmessage\n:\nmay not be null\n,\n                \nmessageTemplate\n:\n{javax.validation.constraints.NotNull.message}\n,\n                \npath\n:\nSampleResources.postUser.user.id\n,\n                \ninvalidValue\n:null\n            },\n            {\n                \nmessage\n:\n'invalid_name' max 5\n,\n                \nmessageTemplate\n:\n'${validatedValue}' max {max}\n,\n                \npath\n:\nSampleResources.postUser.user.name\n,\n                \ninvalidValue\n:\ninvalid_name\n\n            }\n        ],\n        \ncode\n:40001,\n        \nmessage\n:\nconstraint violation validate error unittest\n\n    }\n}\n\n\n\n\nSupported Validation constraints\n\n\n\n\n\n\n\n\nConstraints\n\n\nsupported RDL data type\n\n\nUse\n\n\n\n\n\n\n\n\n\n\nx_min=\"x\"\n\n\nInt8, Int16, Int32, Int64, Byte\n\n\nvalue should be greater or equals x\n\n\n\n\n\n\nx_max=\"x\"\n\n\nInt8, Int16, Int32, Int64, Byte\n\n\nvalue should be less or equals x\n\n\n\n\n\n\nx_size=\"min=x,max=y\"\n\n\nString, Array, Map\n\n\nvalue should be between x and y (inclusive)\n\n\n\n\n\n\nx_pattern=\"regexp=\"x\"\"\n\n\nString\n\n\nvalue should match the regex defined by x\n\n\n\n\n\n\nx_must_validate\n\n\nStruct\n\n\nPerforms validation recursively on the associated object\n\n\n\n\n\n\nx_name=\"x\"\n\n\nString\n\n\nuse x instead if the originl rdl name to get input value\n\n\n\n\n\n\nx_not_null\n\n\nany type\n\n\nvalue should be not null\n\n\n\n\n\n\nx_not_blank\n\n\nString\n\n\nvalue should be not null and size is greater than zero\n\n\n\n\n\n\nx_not_empty\n\n\nArray, Map\n\n\nthe size of the value must be greater than 0 and is not null\n\n\n\n\n\n\nx_country_code\n\n\nString\n\n\nISO 639 country code, in lower case\n\n\n\n\n\n\nx_currency\n\n\nString\n\n\nISO 4217 currency\n\n\n\n\n\n\nx_language_tag\n\n\nString\n\n\nBCP 47 language tag\n\n\n\n\n\n\nx_null\n\n\nany type\n\n\nvalue should be null\n\n\n\n\n\n\nx_digits=\"integer=x,fraction=y\"\n\n\nfloat32, float64\n\n\nvalue should match x in integer part, and also match y in fraction part\n\n\n\n\n\n\n\n\nUsing Validation Groups\n\n\nValidation groups allows you to control the set of constraints to enable\nper object for an endpoint. Please note that only data object validation\nsupports this feature. The syntax to define constraint validation groups\nfollows this syntax: \nconstraint\n=\"groups=\ngroups\n [,\n\nother settings\n]\"\n. Where:\n\n\n\n\nconstraint\n is one of the constraint in the previous section\n\n\ngroups\n is a \n|\n seperated list of groups that will enable\n    this constraint.\n\n\nother settings\n are other settings supported by the contraint\n\n\n\n\nFor example, this size constraint will only be enabled if group is\ncreate or update:\n\n\nString someField (x_size=\"min=3, max=5, groups=create|update\");\n\n\n\nTo control which validation group to enable for an object in a\nparticular endpoint, use \nx_must_validate=\ngroup name\n syntax.\nPlease be advised that only one validation group may be defined per\nobject at a time. For example:\n\n\nObject someObject (x_must_validate=\"update\");\n\n\n\nPlease note that the defined validation group must exist (i.e. used in\nan object) otherwise you may receive Java compile time errors.\n\n\nPlease see \nExample Adding Validation in\nRDL\n section for example\nusage.\n\n\nFor more details regarding validation groups, please refer to external\nresource \nGrouping\nconstraints\n.\n\n\nCustomizing Validation Error Code and Message\n\n\nCustomize validation error {code}, {message} in DefaultWebListener.java:\n\n\n@WebListener\npublic class DefaultWebListener implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        ServletContext context = sce.getServletContext();\n\n        // add api application servlet with customized validation error code, message\n        final DefaultApplication app = new DefaultApplication();\n        app.property( ParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_CODE, 40001);\n        app.property( ParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_MSG, \"test validation error message\");\n        ...\n     }\n}\n\n\n\nExample Adding Validation in RDL\n\n\n\n\nAdding validation to your name field in User struct at\n    src/main/rdl/sample.rdl\n\n\nHere we set the limitation to User.name\n\n\nThe length of User.name should be \n= 3 \n \n= 5\n\n\n\n\n\n\n\n\n...\n\ntype User struct {\n    string name (x_size=\nmin=3,max=5\n);\n    int32 age;\n}\n\n...\n\n\n\n\n\n\nAdding validation to POST data\n\n\n\n\n...\n\nresource string POST \n/user\n {\n    User user (x_must_validate);\n\n...\n\n\n\n\n\n\nThen we re-generate java code and run the web server\n\n\n\n\n$ gradle parsec-generate\n$ gradle jettyRun\n\n\n\n\n\n\nCheck if the validation works\n\n\n\n\n$ curl -H 'Content-Type: application/json' -d '{\nname\n:\ntest\n,\nage\n:10}' http://localhost:8080/sample/v1/user\n\nHello test!\n\n$ curl -H 'Content-Type: application/json' -d '{\nname\n:\ntest_user\n,\nage\n:10}' http://localhost:8080/sample/v1/user\n\n{\n  \nerror\n: {\n    \ncode\n: 0,\n    \ndetail\n: [\n      {\n        \ninvalidValue\n: \ntest_user\n,\n        \nmessage\n: \nsize must be between 3 and 5\n,\n        \nmessageTemplate\n: \n{javax.validation.constraints.Size.message}\n,\n        \npath\n: \nSampleResources.postUser.arg0.name\n\n      }\n    ],\n    \nmessage\n: \nconstraint violation validate error\n\n  }\n}\n\n\n\n\n\n\nAdding a size constraint for create and update\n\n\n\n\n...\n\ntype User struct {\n    string name (x_size=\nmin=3,max=5,groups=create|update\n);\n    int32 age;\n}\n\n...\n\n\n\n\n\n\nUsing validation groups\n\n\n\n\n...\n\ntype User struct {\n    string name (x_not_null=\ngroups=insert\n,x_size=\nmin=3,max=5,groups=insert|update\n);\n    string occupation (x_not_null=\ngroups=update\n, x_size=\nmin=4,groups=update|insert\n);\n    int32 age;\n}\n\n\nresource string POST \n/users\n {\n    User user (x_must_validate=\ninsert\n);\n\n    ...\n}\n\nresource string PUT \n/users/{id}\n {\n    int32 id ;\n\n    User user (x_must_validate=\nupdate\n);\n\n    ....\n}\n\n...\n\n\n\n\nWith the example above, a \"post\" request to /users would be checked against the following rules:\n\n\n\n\n\n\nthe name field is required, the length of its value should be\n       from 3 to 5 chars inclusive.\n\n\nthe occupation field is NOT required, but when it is presented\n       the length of its value should be longer than 4 chars\n\n\nthe age field is not required and wouldn't be checked\n\n\n\n\n\n\nAnd a \"put\" request to users/{id} would be checked against the following rules:\n\n\n\n\n\n\nthe name field is NOT required, but when it is presented the\n       length of its value should be from 3 to 5 chars inclusive.\n\n\nthe occupation field is required, the length of its value should\n       be longer than 4 chars\n\n\nthe age field is not required and wouldn't be checked\n\n\n\n\n\n\nParsec Config\n\n\nPurpose\n\n\n\n\nProvide a library to define configuration by environment (such as\n    alpha, beta, production)\n\n\nIntroduce a best practice for Java web application configuration\n    definition\n\n\nSupply a config library that is compatible with Manhattan\u2019s\n    environment\n\n\n\n\nImplementation Steps\n\n\nLet's get started, you can easily understand how to use this library by\nperforming the following steps:\n\n\nStep 1: Construct your configurations\n\n\n\n\n\n\ndefine shared and environment specific settings\n\n\nplace your configuration files under \nProject\n    Directory\n/src/main/resources/,\n so Parsec config library can\n    find them\n\n\nconfiguration examples as below:\n\n\n\n\n\n\ndev.example.conf\n (environment specific setting):\n\n\ninclude \ncommon_default.conf\n\n\nsimpleKey = simpleValue\nnumber = 123\nduration = 10m\nboolean = true\n\ndb {\n    driver = com.mysql.jdbc.Driver\n    username = testuser\n    keyname = aabb\n}\n\nbooleanList: [ true, false, true ]\nnumberList: [ 1, 2, 3, 4, 5, 6 ]\nstringList: [ \nabc\n, \n456\n, \nxyz\n ]\ndurationList: [ 10m, 300s ]\n\nconfigList: [\n    {\n        key1 = val1\n    }\n    {\n        key2 = val2\n    }\n]\n\n\n\n\ncommon_default.conf\n (shared setting):\n\n\nsimpleKey = defaultValue\ncommon {\n   errorMsg = this is a error\n}\n\n\n\n\nStep 2: Include parsec_config dependency in build.gradle\n\n\nAdd \nparse_config\n dependency in \nbuild.gradle\n:\n\n\ncompile group: 'com.yahoo.parsec', name: 'parsec-config', version: '0.0.15'\n\n\n\n\nStep 3: Adopt parsec_config to your code\n:\n\n\npublic class ExampleConfig {\n  static final ParsecConfig CONFIG = ParsecConfigFactory.load();\n\n  public String getDbUserName() {\n    return CONFIG.getString(\ndb.username\n);\n  }\n\n  public String getErrorMessage() {\n    return CONFIG.getString(\ncommon.errorMsg\n);\n  }\n}\n\n\n\n\nStep 4: Setup environment settings for different environments\n:\n\n\nWe use \nparsec.conf.env.context\n system property key to identify the\nenvironment. In other words, specifying\n\n-Dparsec.conf.env.context=tp2.conf\n in JVM command line argument would\ncause the library to read tp2.conf in resources.\n\n\nTo configure for Gradle unit testing, set \nparsec.conf.env.context\n\nproperty to \ndev.example.conf\n in your gradle.properties. Example as below:\n\n\nsystemProp.parsec.conf.env.context=dev.example.conf\n\n\n\n\nOr you could specify \nSystem.setProperty(ParsecConfigFactory.ENV_KEY,\n\"dev.example.conf\")\n in your test code\n\n\nReference\n\n\n\n\n\n\nparsec_config\n    GitHub\n\n\ntypesafe lib git doc\n\n\n\n\n\n\nParsec Client\n\n\nPurpose\n\n\nProvide a async HTTP client that can support the following \nrequirements:\n\n\n\n\n\n\nPer request retry by response HTTP status code\n\n\nCookie and header back posting\n\n\nShort duration session/response cache (for GET method only)\n\n\nProfiling logs (connection time, and etc)\n\n\nSplunk compatible log\n\n\n\n\n\n\nBasic Usage Example\n\n\nCode example for basic usage example:\n\n\n// Initializing a client\nParsecAsyncHttpClient client = new ParsecAsyncHttpClient.Builder().build();\n\n// Initialize a GET request\nParsecAsyncHttpRequest request = new ParsecAsyncHttpRequest.Builder()\n    .setUrl(\"http://api.yahoo.com:4080\")\n    .addQueryParam(\"mid\", \"12345\")  // Adding a query parameter\n    .addHeader(\"X-ESI\", \"1\")        // Adding a header\n    .build();\n\n// Executing a request\nFuture\nResponse\n future = client.execute(request);\n\n// Initialize a POST request\nParsecAsyncHttpRequest postRequest = new ParsecAsyncHttpRequest.Builder()\n    .setMethod(\"POST\")\n    .setUrl(\"http://api.yahoo.com:4080\")\n    .addFormParam(\"title\", \"My title\")    // Adding form parameters\n    .build();\n\n// Executing a blocking request\nResponse response = client.execute(postRequest).get();\n\n\n\nAsynchronous and Blocking Requests\n\n\nBoth ParsecAsyncHttpClient.execute and ParsecAsyncHttpClient.criticalExecute\nreturns CompletableFuture and is therefore asynchronous / non-blocking by nature. \nIf you need to make blocking calls, please use CompletableFuture.get method.\n\n\nRetrying Requests by Response HTTP Status Code\n\n\nRequests can be retried based on the response's HTTP status code. To add\nor remove a retry HTTP status code, please use\nParsecAsyncHttpRequest.Builder.addRetryStatusCode and\nParsecAsyncHttpRequest.Builder.removeRetryStatusCode method. \nThe maximum number of \ntotal\n retries for all status code can\nbe controlled using ParsecAsyncHttpRequest.Builder.setMaxRetries\nmethod.\n\n\nFor example, the following code will create a request object that\nretries response status code 404 and 500 for a total of 2 times:\n\n\nParsecAsyncHttpRequest request = new ParsecAsyncHttpRequest.Builder()\n    .setUrl(\"http://tw.yahoo.com\")\n    .addRetryStatusCode(404)\n    .addRetryStatusCode(500)\n    .setMaxRetries(2)\n    .build();\n\n\n\nIn Memory Short Duration Response Cache\n\n\nBy default the client enables an in memory short duration loading cache\nfor \nGET\n requests. This means for all identical \nGET\n requests that\noccur in a 2 seconds window, only the first request will be executed\nwhile all remaining requests will be responded from cache. If fresh copy\nof the data is required (for example, during a get update get scenario),\nplease use ParsecAsyncHttpClient.criticalExecute method or\nParsecAsyncHttpRequest.Builder.setCriticalGet method.\n\n\nLog Requests and Responses\n\n\nRequests and responses to and from a ParsecAsyncHttpClient can be logged with \nRequestResponeLoggingFilter\n. Follow the 3 simple steps to enable this:\n\n\nRequestFilter loggingFilter = new RequestResponeLoggingFilter(new NingJsonFormatter());  //  (1)\n\nParsecAsyncHttpClient parsecHttpClient = new ParsecAsyncHttpClient.Builder()\n            .setAcceptAnyCertificate(true)\n            .addRequestFilter(loggingFilter) \n            .build();                                                                   //   (2)\n\n\n\n\n\nCreate a \nRequestResponeLoggingFilter\n, as shown above (1).\n\n\nThe only mandatory parameter for the constructor is an instance of \nNingRequestResponseFormatter\n, which dedicates how to present the Request and Response data in the log.\n\n\nBy default, the filter only logs \npost\n, \nput\n and \ndelete\n requests and response. This can be changed with a different instance of \nBiPredicate\nRequest, ResponseOrThrowable\n \n\n\nBy   default, the logger name for request/response logging is \nparsec.clients.reqresp_log\n. This can be changed by passing a different name in the constructor. \n\n\n\n\n\n\nAdd the filter to the ParsecAsyncHttpClient builder method, as shown above (2).\n\n\nConfigure \nlogback.xml\n to enable the trace level of \"parsec.clients.reqresp_log\" logger.  Note that the log name is configurable from the \nRequestResponeLoggingFilter\n constructor.\n\n\n\n\nconfiguration scan=\nfalse\n\n    \n!-- omit the other settings --\n\n    \nlogger name=\nparsec.clients.reqresp_log\n level=\ntrace\n /\n\n\n/configuration\n\n\n\n\n\nSee also\n\n\n\n\nRequestResponeLoggingFilter.java\n\n\nRequestResponeLoggingFilterTest.java\n\n\nNingJsonFormatter.java\n\n\n\n\nWeb Utilities\n\n\nRequestResponseLoggingFilter\n\n\nAdd \nRequestResponseLoggingFilter\n to your servlet filter chain to log reqeusts and responses received and sent by the service.\n\n\nIf you use a \nServletContextListener\n, add the following code to the \ncontextInitialized\n method: \n\n\n@Override\npublic void contextInitialized(ServletContextEvent sce) {\n    //..omit unrelated code\n\n    ServletContext servletContext = sce.getServletContext();\n    FilterRegistration.Dynamic loggingFilter = servletContext.addFilter(\nRequestResponseLoggingFilter\n,\n            RequestResponseLoggingFilter.class);\n\n    loggingFilter.setInitParameter(\nformatter-classname\n, \ncom.yahoo.parsec.web.JsonFormatter\n);\n    loggingFilter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, \n/endpointUri/*\n);\n}", 
            "title": "Supporting Libraries and Utilities"
        }, 
        {
            "location": "/util/#supporting-libraries-and-utilities", 
            "text": "", 
            "title": "Supporting Libraries and Utilities"
        }, 
        {
            "location": "/util/#input-validation", 
            "text": "", 
            "title": "Input Validation"
        }, 
        {
            "location": "/util/#purpose", 
            "text": "Define standard method for input validation in Parsec Java web\n    applications  Support web applications\u2019 requirement to validate user input\n    depending on their business logic", 
            "title": "Purpose"
        }, 
        {
            "location": "/util/#design-and-implementation", 
            "text": "Adopt  bean validation in\n    Jersey ,\n    which is Jersey framework\u2019s native feature  Jersey bean validation depends directly on Hibernate Validator, it\n    supports validating all forms of input from Jersey framework. Such\n    as @PathParam, @QueryParam, @FormParam, and request body json\n    object by declaring hibernate validation annotations (such as\n    @Size, @Null, @NotNull, \u2026) ( section builtin constraints\n    doc )  parsec_validation Java package  requires jersey-bean-validation dependency  parsec_validation added to dependency by default if project\n    inherits  Parsec Base\n    Build  when parsec_validation is added to dependency (in build.gradle),\n    validation feature will be enabled automatically without\n    requiring any additional function calls  Implemented ParsecValidationExceptionMapper to catch\n    ConstraintViolationException exception (which is thrown by\n    Hibernate Validator)    User can also customize their validation exception {code},\n    {message} by defining server properties in DefaultWebListener.java  ParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_CODE  ParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_MSG    Implemented ParsecValidationAutoDiscoverable to register higher\n    priority for ParsecConstraintViolationExceptionMapper (because the\n    default priority of Jersey's ConstraintViolationExceptionMapper\n    for ConstraintViolationException is higher than others)  Integrate hibernate validation annotation with Parsec RDL\n    Generator (see  RDL + Parsec RDL\n    Generator )  define hibernate validation annotation in .rdl then the\n    annotations will be generated    Validation\n    github    default build.gradle snippet:  dependencies {\n    //...\n    compile group: 'com.yahoo.parsec', name: 'parsec-validation', version: '0.0.15'\n    //...\n}  error layout example:  {\n     error :{\n         detail :[\n            {\n                 message : may not be null ,\n                 messageTemplate : {javax.validation.constraints.NotNull.message} ,\n                 path : SampleResources.postUser.user.id ,\n                 invalidValue :null\n            },\n            {\n                 message : 'invalid_name' max 5 ,\n                 messageTemplate : '${validatedValue}' max {max} ,\n                 path : SampleResources.postUser.user.name ,\n                 invalidValue : invalid_name \n            }\n        ],\n         code :40001,\n         message : constraint violation validate error unittest \n    }\n}", 
            "title": "Design and implementation"
        }, 
        {
            "location": "/util/#supported-validation-constraints", 
            "text": "Constraints  supported RDL data type  Use      x_min=\"x\"  Int8, Int16, Int32, Int64, Byte  value should be greater or equals x    x_max=\"x\"  Int8, Int16, Int32, Int64, Byte  value should be less or equals x    x_size=\"min=x,max=y\"  String, Array, Map  value should be between x and y (inclusive)    x_pattern=\"regexp=\"x\"\"  String  value should match the regex defined by x    x_must_validate  Struct  Performs validation recursively on the associated object    x_name=\"x\"  String  use x instead if the originl rdl name to get input value    x_not_null  any type  value should be not null    x_not_blank  String  value should be not null and size is greater than zero    x_not_empty  Array, Map  the size of the value must be greater than 0 and is not null    x_country_code  String  ISO 639 country code, in lower case    x_currency  String  ISO 4217 currency    x_language_tag  String  BCP 47 language tag    x_null  any type  value should be null    x_digits=\"integer=x,fraction=y\"  float32, float64  value should match x in integer part, and also match y in fraction part", 
            "title": "Supported Validation constraints"
        }, 
        {
            "location": "/util/#using-validation-groups", 
            "text": "Validation groups allows you to control the set of constraints to enable\nper object for an endpoint. Please note that only data object validation\nsupports this feature. The syntax to define constraint validation groups\nfollows this syntax:  constraint =\"groups= groups  [, other settings ]\" . Where:   constraint  is one of the constraint in the previous section  groups  is a  |  seperated list of groups that will enable\n    this constraint.  other settings  are other settings supported by the contraint   For example, this size constraint will only be enabled if group is\ncreate or update:  String someField (x_size=\"min=3, max=5, groups=create|update\");  To control which validation group to enable for an object in a\nparticular endpoint, use  x_must_validate= group name  syntax.\nPlease be advised that only one validation group may be defined per\nobject at a time. For example:  Object someObject (x_must_validate=\"update\");  Please note that the defined validation group must exist (i.e. used in\nan object) otherwise you may receive Java compile time errors.  Please see  Example Adding Validation in\nRDL  section for example\nusage.  For more details regarding validation groups, please refer to external\nresource  Grouping\nconstraints .", 
            "title": "Using Validation Groups"
        }, 
        {
            "location": "/util/#customizing-validation-error-code-and-message", 
            "text": "Customize validation error {code}, {message} in DefaultWebListener.java:  @WebListener\npublic class DefaultWebListener implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        ServletContext context = sce.getServletContext();\n\n        // add api application servlet with customized validation error code, message\n        final DefaultApplication app = new DefaultApplication();\n        app.property( ParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_CODE, 40001);\n        app.property( ParsecValidationExceptionMapper.PROP_VALIDATION_DEFAULT_ERROR_MSG, \"test validation error message\");\n        ...\n     }\n}", 
            "title": "Customizing Validation Error Code and Message"
        }, 
        {
            "location": "/util/#example-adding-validation-in-rdl", 
            "text": "Adding validation to your name field in User struct at\n    src/main/rdl/sample.rdl  Here we set the limitation to User.name  The length of User.name should be  = 3    = 5     ...\n\ntype User struct {\n    string name (x_size= min=3,max=5 );\n    int32 age;\n}\n\n...   Adding validation to POST data   ...\n\nresource string POST  /user  {\n    User user (x_must_validate);\n\n...   Then we re-generate java code and run the web server   $ gradle parsec-generate\n$ gradle jettyRun   Check if the validation works   $ curl -H 'Content-Type: application/json' -d '{ name : test , age :10}' http://localhost:8080/sample/v1/user\n\nHello test!\n\n$ curl -H 'Content-Type: application/json' -d '{ name : test_user , age :10}' http://localhost:8080/sample/v1/user\n\n{\n   error : {\n     code : 0,\n     detail : [\n      {\n         invalidValue :  test_user ,\n         message :  size must be between 3 and 5 ,\n         messageTemplate :  {javax.validation.constraints.Size.message} ,\n         path :  SampleResources.postUser.arg0.name \n      }\n    ],\n     message :  constraint violation validate error \n  }\n}   Adding a size constraint for create and update   ...\n\ntype User struct {\n    string name (x_size= min=3,max=5,groups=create|update );\n    int32 age;\n}\n\n...   Using validation groups   ...\n\ntype User struct {\n    string name (x_not_null= groups=insert ,x_size= min=3,max=5,groups=insert|update );\n    string occupation (x_not_null= groups=update , x_size= min=4,groups=update|insert );\n    int32 age;\n}\n\n\nresource string POST  /users  {\n    User user (x_must_validate= insert );\n\n    ...\n}\n\nresource string PUT  /users/{id}  {\n    int32 id ;\n\n    User user (x_must_validate= update );\n\n    ....\n}\n\n...  With the example above, a \"post\" request to /users would be checked against the following rules:    the name field is required, the length of its value should be\n       from 3 to 5 chars inclusive.  the occupation field is NOT required, but when it is presented\n       the length of its value should be longer than 4 chars  the age field is not required and wouldn't be checked    And a \"put\" request to users/{id} would be checked against the following rules:    the name field is NOT required, but when it is presented the\n       length of its value should be from 3 to 5 chars inclusive.  the occupation field is required, the length of its value should\n       be longer than 4 chars  the age field is not required and wouldn't be checked", 
            "title": "Example Adding Validation in RDL"
        }, 
        {
            "location": "/util/#parsec-config", 
            "text": "", 
            "title": "Parsec Config"
        }, 
        {
            "location": "/util/#purpose_1", 
            "text": "Provide a library to define configuration by environment (such as\n    alpha, beta, production)  Introduce a best practice for Java web application configuration\n    definition  Supply a config library that is compatible with Manhattan\u2019s\n    environment", 
            "title": "Purpose"
        }, 
        {
            "location": "/util/#implementation-steps", 
            "text": "Let's get started, you can easily understand how to use this library by\nperforming the following steps:  Step 1: Construct your configurations    define shared and environment specific settings  place your configuration files under  Project\n    Directory /src/main/resources/,  so Parsec config library can\n    find them  configuration examples as below:    dev.example.conf  (environment specific setting):  include  common_default.conf \n\nsimpleKey = simpleValue\nnumber = 123\nduration = 10m\nboolean = true\n\ndb {\n    driver = com.mysql.jdbc.Driver\n    username = testuser\n    keyname = aabb\n}\n\nbooleanList: [ true, false, true ]\nnumberList: [ 1, 2, 3, 4, 5, 6 ]\nstringList: [  abc ,  456 ,  xyz  ]\ndurationList: [ 10m, 300s ]\n\nconfigList: [\n    {\n        key1 = val1\n    }\n    {\n        key2 = val2\n    }\n]  common_default.conf  (shared setting):  simpleKey = defaultValue\ncommon {\n   errorMsg = this is a error\n}  Step 2: Include parsec_config dependency in build.gradle  Add  parse_config  dependency in  build.gradle :  compile group: 'com.yahoo.parsec', name: 'parsec-config', version: '0.0.15'  Step 3: Adopt parsec_config to your code :  public class ExampleConfig {\n  static final ParsecConfig CONFIG = ParsecConfigFactory.load();\n\n  public String getDbUserName() {\n    return CONFIG.getString( db.username );\n  }\n\n  public String getErrorMessage() {\n    return CONFIG.getString( common.errorMsg );\n  }\n}  Step 4: Setup environment settings for different environments :  We use  parsec.conf.env.context  system property key to identify the\nenvironment. In other words, specifying -Dparsec.conf.env.context=tp2.conf  in JVM command line argument would\ncause the library to read tp2.conf in resources.  To configure for Gradle unit testing, set  parsec.conf.env.context \nproperty to  dev.example.conf  in your gradle.properties. Example as below:  systemProp.parsec.conf.env.context=dev.example.conf  Or you could specify  System.setProperty(ParsecConfigFactory.ENV_KEY,\n\"dev.example.conf\")  in your test code", 
            "title": "Implementation Steps"
        }, 
        {
            "location": "/util/#reference", 
            "text": "parsec_config\n    GitHub  typesafe lib git doc", 
            "title": "Reference"
        }, 
        {
            "location": "/util/#parsec-client", 
            "text": "", 
            "title": "Parsec Client"
        }, 
        {
            "location": "/util/#purpose_2", 
            "text": "Provide a async HTTP client that can support the following \nrequirements:    Per request retry by response HTTP status code  Cookie and header back posting  Short duration session/response cache (for GET method only)  Profiling logs (connection time, and etc)  Splunk compatible log", 
            "title": "Purpose"
        }, 
        {
            "location": "/util/#basic-usage-example", 
            "text": "Code example for basic usage example:  // Initializing a client\nParsecAsyncHttpClient client = new ParsecAsyncHttpClient.Builder().build();\n\n// Initialize a GET request\nParsecAsyncHttpRequest request = new ParsecAsyncHttpRequest.Builder()\n    .setUrl(\"http://api.yahoo.com:4080\")\n    .addQueryParam(\"mid\", \"12345\")  // Adding a query parameter\n    .addHeader(\"X-ESI\", \"1\")        // Adding a header\n    .build();\n\n// Executing a request\nFuture Response  future = client.execute(request);\n\n// Initialize a POST request\nParsecAsyncHttpRequest postRequest = new ParsecAsyncHttpRequest.Builder()\n    .setMethod(\"POST\")\n    .setUrl(\"http://api.yahoo.com:4080\")\n    .addFormParam(\"title\", \"My title\")    // Adding form parameters\n    .build();\n\n// Executing a blocking request\nResponse response = client.execute(postRequest).get();", 
            "title": "Basic Usage Example"
        }, 
        {
            "location": "/util/#asynchronous-and-blocking-requests", 
            "text": "Both ParsecAsyncHttpClient.execute and ParsecAsyncHttpClient.criticalExecute\nreturns CompletableFuture and is therefore asynchronous / non-blocking by nature. \nIf you need to make blocking calls, please use CompletableFuture.get method.", 
            "title": "Asynchronous and Blocking Requests"
        }, 
        {
            "location": "/util/#retrying-requests-by-response-http-status-code", 
            "text": "Requests can be retried based on the response's HTTP status code. To add\nor remove a retry HTTP status code, please use\nParsecAsyncHttpRequest.Builder.addRetryStatusCode and\nParsecAsyncHttpRequest.Builder.removeRetryStatusCode method. \nThe maximum number of  total  retries for all status code can\nbe controlled using ParsecAsyncHttpRequest.Builder.setMaxRetries\nmethod.  For example, the following code will create a request object that\nretries response status code 404 and 500 for a total of 2 times:  ParsecAsyncHttpRequest request = new ParsecAsyncHttpRequest.Builder()\n    .setUrl(\"http://tw.yahoo.com\")\n    .addRetryStatusCode(404)\n    .addRetryStatusCode(500)\n    .setMaxRetries(2)\n    .build();", 
            "title": "Retrying Requests by Response HTTP Status Code"
        }, 
        {
            "location": "/util/#in-memory-short-duration-response-cache", 
            "text": "By default the client enables an in memory short duration loading cache\nfor  GET  requests. This means for all identical  GET  requests that\noccur in a 2 seconds window, only the first request will be executed\nwhile all remaining requests will be responded from cache. If fresh copy\nof the data is required (for example, during a get update get scenario),\nplease use ParsecAsyncHttpClient.criticalExecute method or\nParsecAsyncHttpRequest.Builder.setCriticalGet method.", 
            "title": "In Memory Short Duration Response Cache"
        }, 
        {
            "location": "/util/#log-requests-and-responses", 
            "text": "Requests and responses to and from a ParsecAsyncHttpClient can be logged with  RequestResponeLoggingFilter . Follow the 3 simple steps to enable this:  RequestFilter loggingFilter = new RequestResponeLoggingFilter(new NingJsonFormatter());  //  (1)\n\nParsecAsyncHttpClient parsecHttpClient = new ParsecAsyncHttpClient.Builder()\n            .setAcceptAnyCertificate(true)\n            .addRequestFilter(loggingFilter) \n            .build();                                                                   //   (2)   Create a  RequestResponeLoggingFilter , as shown above (1).  The only mandatory parameter for the constructor is an instance of  NingRequestResponseFormatter , which dedicates how to present the Request and Response data in the log.  By default, the filter only logs  post ,  put  and  delete  requests and response. This can be changed with a different instance of  BiPredicate Request, ResponseOrThrowable    By   default, the logger name for request/response logging is  parsec.clients.reqresp_log . This can be changed by passing a different name in the constructor.     Add the filter to the ParsecAsyncHttpClient builder method, as shown above (2).  Configure  logback.xml  to enable the trace level of \"parsec.clients.reqresp_log\" logger.  Note that the log name is configurable from the  RequestResponeLoggingFilter  constructor.   configuration scan= false \n     !-- omit the other settings -- \n     logger name= parsec.clients.reqresp_log  level= trace  /  /configuration   See also   RequestResponeLoggingFilter.java  RequestResponeLoggingFilterTest.java  NingJsonFormatter.java", 
            "title": "Log Requests and Responses"
        }, 
        {
            "location": "/util/#web-utilities", 
            "text": "", 
            "title": "Web Utilities"
        }, 
        {
            "location": "/util/#requestresponseloggingfilter", 
            "text": "Add  RequestResponseLoggingFilter  to your servlet filter chain to log reqeusts and responses received and sent by the service.  If you use a  ServletContextListener , add the following code to the  contextInitialized  method:   @Override\npublic void contextInitialized(ServletContextEvent sce) {\n    //..omit unrelated code\n\n    ServletContext servletContext = sce.getServletContext();\n    FilterRegistration.Dynamic loggingFilter = servletContext.addFilter( RequestResponseLoggingFilter ,\n            RequestResponseLoggingFilter.class);\n\n    loggingFilter.setInitParameter( formatter-classname ,  com.yahoo.parsec.web.JsonFormatter );\n    loggingFilter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false,  /endpointUri/* );\n}", 
            "title": "RequestResponseLoggingFilter"
        }, 
        {
            "location": "/testing/", 
            "text": "Testing\n\n\nUnit Testing\n\n\nSpock\n\n\nAs the default unit test framework, Spock has a number of features:\n\n\n\n\n\n\nEnables Behavior-Driven Development\n\n\nUses Groovy which makes it easier to develop test cases\n\n\nTests are descriptive, making them easier to understand and manage\n\n\nHas powerful features such as mocking methods by regex match\n\n\n\n\n\n\nIdeally, each piece of Spock code should be fairly self-explanatory. For\ninstance, a test method that checks for non-null variable may look like\nthis:\n\n\nimport spock.lang.Specification\n\nclass MyClassTest extends Specification {\n    def \nensure that foo is not null\n() {\n        given: def myClass = new MyClass()\n        when: def foo = myClass.getFoo()\n        then: foo != null\n    }\n}\n\n\n\n\nAnother example that mocks with sample data in Spock:\n\n\nclass SampleHandlerImplTest extends Specification {    \n    def \ntest post user\n() {\n        given: \n        def impl = new SampleHandlerImpl()\n        def context = Mock(SampleResourceContext)\n        context.request() \n Mock(HttpServletRequest)\n\n        expected:\n        impl.postUser(context, new User().setName(name)) == result\n\n        where:\n        name   || result\n        \njake\n || \n\\\nHello jake!\\\n\\n\n\n    }\n}\n\n\n\n\nBesides being highly descriptive, Spock is also packed with powerful\nfeatures such as regex mocking. For example, to match all setter methods\nof a given object:\n\n\nclass MyClassTest extends Specification {\n    def \nensure that foo is not null\n() {\n        given: def myClass = new MyClass()\n        when: def foo = myClass.getFoo()\n\n        then:\n        foo != null\n        // check if call to any setter of myClass with any argument once\n        1 * myClass./set.*/(_) \n    }\n}\n\n\n\n\nTo learn more about other Spock features, refer to the official \nSpock\ndocumentation\n.\n\n\nNote: By default Spock test files should be placed under\nsrc/test/groovy\n\n\nGetting started with Spock should be straightforward if you are already\nfamiliar with Java or Groovy. If you are unfamiliar with Java, learning\nGroovy would probably be easier than learning Java. Here is some\ndocumentation to get you started:\n\n\n\n\n\n\nSpock\n    Primer\n\n\nGroovy documentation\n\n\n\n\n\n\nOr if you prefer to learn by example or prefer actual code for\nreferencing:\n\n\n\n\n\n\nOfficial Spock\n    example\n\n\n\n\n\n\nAlternative test frameworks\n\n\nAlternative recommend unit test framewords are JUnit and TestNG.\n\n\nJUnit\n\n\nSpock depends on JUnit. Place your test files under \nsrc/test/java\n to\nrun tests with JUnit.\n\n\nTestNG\n\n\nSpock and JUnit conflicts with TestNG. To use TestNG you will need to\nremove \nspock-core\n from your build.gradle and add TestNG dependencies.\n\n\ndependencies {\n    compile group: 'org.spockframework', name: 'spock-core', version: '1.1-groovy-2.4-rc-3'\n}\n\n\n\n\nTestNG on\nmvnrepository.com\n\n\nSmoke and Functional Testing\n\n\nCucumber-JVM + Groovy is the recommended framework for integration tests\nof Parsec services for reasons that include:\n\n\n\n\n\n\nBehaviour Driven Design (BDD)\n reduces the gap between product\n    requirements and software development and is aligned with agile\n    development.\n\n\nCucumber-JVM\n is a tool that implements a BDD workflow.\n    Cucumber-JVM is a pure Java implementation of Cucumber.\n\n\nGroovy\n is a JVM-based language and it\u2019s fully compatible with\n    pure Java libraries.\n\n\nSpock\n is also implemented using Groovy\n\n\n\n\n\n\nBefore you start, make sure the following \nCucumber dependencies are in\nyour build.gradle\n:\n\n\ndependencies {\n    compile group: 'info.cukes', name: 'cucumber-junit', version: '1.2.5'\n    compile group: 'info.cukes', name: 'cucumber-groovy', version: '1.2.5'\n    compile group: 'info.cukes', name: 'cucumber-java', version: '1.2.5'\n}\n\n\n\n\nThe following steps will help you get started:\n\n\n\n\n\n\nwrite scenarios in feature files (*.feature)\n\n\nimplement RunCukesIT.java\n\n\nimplement step definitions (*.groovy)\n\n\nintegrate with CD\n\n\n\n\n\n\nIf you're not familiar with BDD or Cucumber, here are some resources to\nget you started:\n\n\n\n\n\n\nBehavior Driven Development\n    wiki\n\n\nCucumber wiki", 
            "title": "Testing"
        }, 
        {
            "location": "/testing/#testing", 
            "text": "", 
            "title": "Testing"
        }, 
        {
            "location": "/testing/#unit-testing", 
            "text": "", 
            "title": "Unit Testing"
        }, 
        {
            "location": "/testing/#spock", 
            "text": "As the default unit test framework, Spock has a number of features:    Enables Behavior-Driven Development  Uses Groovy which makes it easier to develop test cases  Tests are descriptive, making them easier to understand and manage  Has powerful features such as mocking methods by regex match    Ideally, each piece of Spock code should be fairly self-explanatory. For\ninstance, a test method that checks for non-null variable may look like\nthis:  import spock.lang.Specification\n\nclass MyClassTest extends Specification {\n    def  ensure that foo is not null () {\n        given: def myClass = new MyClass()\n        when: def foo = myClass.getFoo()\n        then: foo != null\n    }\n}  Another example that mocks with sample data in Spock:  class SampleHandlerImplTest extends Specification {    \n    def  test post user () {\n        given: \n        def impl = new SampleHandlerImpl()\n        def context = Mock(SampleResourceContext)\n        context.request()   Mock(HttpServletRequest)\n\n        expected:\n        impl.postUser(context, new User().setName(name)) == result\n\n        where:\n        name   || result\n         jake  ||  \\ Hello jake!\\ \\n \n    }\n}  Besides being highly descriptive, Spock is also packed with powerful\nfeatures such as regex mocking. For example, to match all setter methods\nof a given object:  class MyClassTest extends Specification {\n    def  ensure that foo is not null () {\n        given: def myClass = new MyClass()\n        when: def foo = myClass.getFoo()\n\n        then:\n        foo != null\n        // check if call to any setter of myClass with any argument once\n        1 * myClass./set.*/(_) \n    }\n}  To learn more about other Spock features, refer to the official  Spock\ndocumentation .  Note: By default Spock test files should be placed under\nsrc/test/groovy  Getting started with Spock should be straightforward if you are already\nfamiliar with Java or Groovy. If you are unfamiliar with Java, learning\nGroovy would probably be easier than learning Java. Here is some\ndocumentation to get you started:    Spock\n    Primer  Groovy documentation    Or if you prefer to learn by example or prefer actual code for\nreferencing:    Official Spock\n    example", 
            "title": "Spock"
        }, 
        {
            "location": "/testing/#alternative-test-frameworks", 
            "text": "Alternative recommend unit test framewords are JUnit and TestNG.", 
            "title": "Alternative test frameworks"
        }, 
        {
            "location": "/testing/#junit", 
            "text": "Spock depends on JUnit. Place your test files under  src/test/java  to\nrun tests with JUnit.", 
            "title": "JUnit"
        }, 
        {
            "location": "/testing/#testng", 
            "text": "Spock and JUnit conflicts with TestNG. To use TestNG you will need to\nremove  spock-core  from your build.gradle and add TestNG dependencies.  dependencies {\n    compile group: 'org.spockframework', name: 'spock-core', version: '1.1-groovy-2.4-rc-3'\n}  TestNG on\nmvnrepository.com", 
            "title": "TestNG"
        }, 
        {
            "location": "/testing/#smoke-and-functional-testing", 
            "text": "Cucumber-JVM + Groovy is the recommended framework for integration tests\nof Parsec services for reasons that include:    Behaviour Driven Design (BDD)  reduces the gap between product\n    requirements and software development and is aligned with agile\n    development.  Cucumber-JVM  is a tool that implements a BDD workflow.\n    Cucumber-JVM is a pure Java implementation of Cucumber.  Groovy  is a JVM-based language and it\u2019s fully compatible with\n    pure Java libraries.  Spock  is also implemented using Groovy    Before you start, make sure the following  Cucumber dependencies are in\nyour build.gradle :  dependencies {\n    compile group: 'info.cukes', name: 'cucumber-junit', version: '1.2.5'\n    compile group: 'info.cukes', name: 'cucumber-groovy', version: '1.2.5'\n    compile group: 'info.cukes', name: 'cucumber-java', version: '1.2.5'\n}  The following steps will help you get started:    write scenarios in feature files (*.feature)  implement RunCukesIT.java  implement step definitions (*.groovy)  integrate with CD    If you're not familiar with BDD or Cucumber, here are some resources to\nget you started:    Behavior Driven Development\n    wiki  Cucumber wiki", 
            "title": "Smoke and Functional Testing"
        }, 
        {
            "location": "/endpoint/", 
            "text": "API Endpoint Definition\n\n\nParsec integrates RDL, Swagger, and gradle jetty plugin, allowing users\nto test web applications on local development machines.\n\n\nIn order to make endpoints across local Jetty, Swagger JSON schema, and\nProduction Jetty consistent, you will need to adjust some settings in\nproject pom and RDL files. Doing so also ensures compatibility with both\nYinst based and Manhattan environments.\n\n\nUnderstanding related settings about API endpoint\n\n\nYou \nDon't\n need to understand this section if you are deploying a web\napplication to Manhattan\n\n\n\n\nThere are four settings you need to care about if you would like to\n    change the root path of API endpoint:\n\n\nartifact id\n (pom): \"artifactId\" in pom\n\n\nThe project name, .i.e: \"echo\"\n\n\n\n\n\n\nfinal name\n (pom): \"finalName\" in build section of pom\n\n\nThe name of war.\n\n\nThe default value will be the same with {artifact id}\n\n\nWe setting as \"api\" by default, you could modify as you like.\n\n\nThis name will become the first path segment of API\n    endpoints in runtime enviornment by default\n\n\nEnd point example: /{pom.finalName}/echo/v1/users\n\n\n\n\n\n\nwebapp root path\n (pom): \"parsec.webapp_root_path\" in pom's\n    property\n\n\nThis is just like contextPath setting in Jetty, but only\n    influences local Jetty and Swagger JSON schema\n\n\nThe default value is \"/api\"\n\n\nEnd point example: {parsec.webapp_root_path}/echo/v1/users", 
            "title": "API Endpoint Definition"
        }, 
        {
            "location": "/endpoint/#api-endpoint-definition", 
            "text": "Parsec integrates RDL, Swagger, and gradle jetty plugin, allowing users\nto test web applications on local development machines.  In order to make endpoints across local Jetty, Swagger JSON schema, and\nProduction Jetty consistent, you will need to adjust some settings in\nproject pom and RDL files. Doing so also ensures compatibility with both\nYinst based and Manhattan environments.", 
            "title": "API Endpoint Definition"
        }, 
        {
            "location": "/endpoint/#understanding-related-settings-about-api-endpoint", 
            "text": "You  Don't  need to understand this section if you are deploying a web\napplication to Manhattan   There are four settings you need to care about if you would like to\n    change the root path of API endpoint:  artifact id  (pom): \"artifactId\" in pom  The project name, .i.e: \"echo\"    final name  (pom): \"finalName\" in build section of pom  The name of war.  The default value will be the same with {artifact id}  We setting as \"api\" by default, you could modify as you like.  This name will become the first path segment of API\n    endpoints in runtime enviornment by default  End point example: /{pom.finalName}/echo/v1/users    webapp root path  (pom): \"parsec.webapp_root_path\" in pom's\n    property  This is just like contextPath setting in Jetty, but only\n    influences local Jetty and Swagger JSON schema  The default value is \"/api\"  End point example: {parsec.webapp_root_path}/echo/v1/users", 
            "title": "Understanding related settings about API endpoint"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nResolved\n\n\nHow do I add default value in response header for specific end points?\n\n\n\n\nIt seems there is no existing filter to handle response header.\n\n\nyou can add headers to ResourceContext of specific endpoints\n    implementation example as below:\n\n\n\n\nSampleHandlerImpl.java\n\n\n@Override\npublic Users getUsers(ResourceContext context, String ids) {\n    List\nString\n idList = Arrays.asList(ids.split(\n,\n));\n    List\nUser\n userList = new ArrayList\nUser\n();\n    for (String id : idList) {\n        User u = new User();\n        u.setId(id);\n        u.setName(\nname_\n + id);\n        userList.add(u);\n    }\n\n    // prepare response object\n    Users users = new Users();\n    users.setUsers(userList);\n\n    // set cache control header 24h\n    long expires = System.currentTimeMillis() + EXPIRES_IN_MS;\n\n    context.response().setHeader(\nCache-Control\n, \npublic\n);\n    context.response().setDateHeader(\nExpires\n, expires);\n    return users;\n}\n\n\n\n\nHow do I show detailed or backtrace log when server has errors?\n\n\n\n\nFor local Jetty, edit gradle.properties setting:\n\n\n\n\nsystemProp.log4j.debug=1\n\n\n\n\nHow do I display \noptional\n or \nrequired\n for data object\u2019s sub field in Swagger UI?\n\n\n\n\nfield \u201cname\u201d will be described with required, and the words after\n    \u201c//\u201d will be displayed as the field\u2019s description\n\n\nclick on \u201cModel\u201d link (located in \u201cData Type\u201d column)\n\n\n\n\nsample.rdl\n\n\ntype User struct {\n    string name (x_size=\nmin=3,max=5\n, optional); // desc for required name\n    int32 age; // desc for optional age\n}\n\n\n\n\nHow do I enable filter for specific endpoint?\n\n\n\n\nregister filter to specific servlet whose name is \u201cWeb Application\u201d\n\n\n\n\nFilterRegistration.Dynamic fooFilter = context.addFilter(\nFooFilter\n, FOOFilter.class);\nfooFilter.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), true, \nWeb Application\n);\nfooFilter.setInitParameter(\nkey\n, \nval\n);\n\n\n\n\n\n\nregister filter to specific endpoint which url matches \u201c/*\u201d\n\n\n\n\nFilterRegistration.Dynamic fooFilter = context.addFilter(\nFooFilter\n, FOOFilter.class);\nfooFilter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST) ,true,\n/*\n);\nfooFilter.setInitParameter(\nkey\n, \nval\n);\n\n\n\n\nHow do I define different constraint rules in same data object for different endpoint?\n\n\nUse \"validation groups\". Please refer to \nInput Validation\n for details.\n\n\nIs it possible for one data object to extend another?\n\n\n\n\nIn RDL, you can define one type that include another as shown below:  \n\n\nIn this RDL snippet, a type Foo is defined. And a type Bar include fields in type Foo, with one additional field \nbarField\n.\n\n\n\n\n\ntype Foo struct {\n   String  fooField1;\n   String  fooField2;\n   Int32   fooField3;\n\n}\n\n\ntype Bar Foo {\n    String    barField;\n}\n\n\n\n\n\nThe generated Java classes of these two type doesn't preserve the \"inheritance\" relationship, but all fields from the \"base\" type \nFoo\n would be included in class \nBar\n, as shown below:\n\n\n\npublic final class Foo implements java.io.Serializable {\n\n    private String fooField1;    // (1)\n\n    private String fooField2;    // (2)\n\n    private int fooField3;       // (3)\n\n\n\n    // unrelated code is omitted ...\n}\n\n\n\npublic final class Bar implements java.io.Serializable {\n\n    private String fooField1;    // (1)\n\n    private String fooField2;    // (2)\n\n    private int fooField3;       // (3)\n\n    private String barField;     // (4)\n\n\n    // unrelated code is omitted ...\n}\n\n\n\n\n\nNote that both classes have 3 common fields (\nfooField1\n, \nfooField2\n and \nfooField3\n ) however \nBar\n doesn't extend from another.\n\n\nHow do I define customized error layout?\n\n\n\n\ndefine your error object in .rdl, and specify status code mapping to\n    your custom data object\n\n\n\n\nsample.rdl\n\n\ntype MyResourceError struct {\n    string errorValue;\n}\n\nresource User GET \n/user/{id}\n {\n    int32 id;\n\n    expected ACCEPTED;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        MyResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n}\n\n\n\n\n\n\nthe custom error object and exception mapping of endpoint resources\n    will be generated by rdl generator\n\n\n\n\nSampleResources.java (No need to implemented)\n\n\n@Path(\n/sample/v1\n)\npublic class SampleResources {\n\n   @GET\n   @Path(\n/user/{id}\n)\n   @Produces(MediaType.APPLICATION_JSON)\n   public User getUser(\n       @PathParam(\nid\n) Integer id\n   ) {\n       try {\n           ResourceContext context = _delegate.newResourceContext(_request, _response);\n           User e = _delegate.getUser(context, id);\n           return e;\n       } catch (ResourceException e) {\n           int code = e.getCode();\n           switch (code) {\n           case ResourceException.BAD_REQUEST:\n               throw typedException(code, e, MyResourceError.class);\n           case ResourceException.UNAUTHORIZED:\n               throw typedException(code, e, ResourceError.class);\n           case ResourceException.FORBIDDEN:\n               throw typedException(code, e, ResourceError.class);\n           case ResourceException.INTERNAL_SERVER_ERROR:\n               throw typedException(code, e, ResourceError.class);\n           default:\n               System.err.println(\n*** Warning: undeclared exception (\n+code+\n) for resource getUser\n);\n               throw typedException(code, e, ResourceError.class);\n           }\n       }\n   }\n}\n\n\n\n\nMyResourceError.java (No need to implemented)\n\n\npublic class MyResourceError {\n\n   public String errorValue;\n\n   public MyResourceError message(String errorValue) {\n       this.errorValue = errorValue;\n       return this;\n   }\n\n   public String toString() {\n       return \n{errorValue: \\\n + errorValue + \n\\\n}\n;\n   }\n\n}\n\n\n\n\n\n\nyou only need to throw ResourceException with your custom error\n    object (the code must match with the object you defined in rdl)\n\n\n\n\npublic class SampleHandlerImpl implements SampleHandler {\n\n   @Override\n   public User getUser(ResourceContext context, Integer id) {\n       User user = new User();\n       user.setName(\ndm4\n);\n\n       // throw your custom error object depends on your business logic\n       if (id \n 100) {\n           MyResourceError e = new MyResourceError();\n           e.setErrorValue(id + \n is invalid\n);\n           throw new ResourceException(ResourceException.BAD_REQUEST, e);\n       }\n       return user;\n   }\n\n   ...\n}\n\n\n\n\n\n\nthe output will be\n\n\n\n\n$ curl -v http://wifi-9-152.tpcity.corp.yahoo.com:8080/api/sample/v1/user/101\n\n* Hostname was NOT found in DNS cache\n*   Trying 10.82.9.152...\n* Connected to wifi-9-152.tpcity.corp.yahoo.com (10.82.9.152) port 8080 (#0)\n\n GET /api/sample/v1/user/101 HTTP/1.1\n\n User-Agent: curl/7.37.1\n\n Host: wifi-9-152.tpcity.corp.yahoo.com:8080\n\n Accept: */*\n\n\n\n HTTP/1.1 400 Bad Request\n\n Date: Fri, 04 Sep 2015 02:13:18 GMT\n\n Content-Type: application/json\n\n Content-Length: 34\n* Server Jetty(9.3.0.M2) is not blacklisted\n\n Server: Jetty(9.3.0.M2)\n\n\n* Connection #0 to host wifi-9-152.tpcity.corp.yahoo.com left intact\n{\nerrorValue\n:\n101 is invalid\n}\n\n\n\n\nHow to change slf4j logger binding?\n\n\n\n\nParsec archetype generate build.gradle default binding implementation to\n    log4j, you could change to logback or any other logger\n    implementation what you like.\n\n\nBelow build.gradle example demo howto change binding to logback\n\n\n\n\ndependencies {\n    // ...\n    compile group: 'ch.qos.logback', name: 'logback-classic', version: '1.1.9'\n    // ...\n}\n\n\n\n\n\n\nDetail info could reference \nslf4j\n    doc\n\n\n\n\nPending\n\n\nWhat does \u201cpublic void authorize(String action, String resource, String trustedDomain)\u201d mean (rdl generated code) and how do I use it?\n\n\nHow do I define webapp root path?\n\n\nHow do I define multipart in rdl?", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#resolved", 
            "text": "", 
            "title": "Resolved"
        }, 
        {
            "location": "/faq/#how-do-i-add-default-value-in-response-header-for-specific-end-points", 
            "text": "It seems there is no existing filter to handle response header.  you can add headers to ResourceContext of specific endpoints\n    implementation example as below:   SampleHandlerImpl.java  @Override\npublic Users getUsers(ResourceContext context, String ids) {\n    List String  idList = Arrays.asList(ids.split( , ));\n    List User  userList = new ArrayList User ();\n    for (String id : idList) {\n        User u = new User();\n        u.setId(id);\n        u.setName( name_  + id);\n        userList.add(u);\n    }\n\n    // prepare response object\n    Users users = new Users();\n    users.setUsers(userList);\n\n    // set cache control header 24h\n    long expires = System.currentTimeMillis() + EXPIRES_IN_MS;\n\n    context.response().setHeader( Cache-Control ,  public );\n    context.response().setDateHeader( Expires , expires);\n    return users;\n}", 
            "title": "How do I add default value in response header for specific end points?"
        }, 
        {
            "location": "/faq/#how-do-i-show-detailed-or-backtrace-log-when-server-has-errors", 
            "text": "For local Jetty, edit gradle.properties setting:   systemProp.log4j.debug=1", 
            "title": "How do I show detailed or backtrace log when server has errors?"
        }, 
        {
            "location": "/faq/#how-do-i-display-optional-or-required-for-data-objects-sub-field-in-swagger-ui", 
            "text": "field \u201cname\u201d will be described with required, and the words after\n    \u201c//\u201d will be displayed as the field\u2019s description  click on \u201cModel\u201d link (located in \u201cData Type\u201d column)   sample.rdl  type User struct {\n    string name (x_size= min=3,max=5 , optional); // desc for required name\n    int32 age; // desc for optional age\n}", 
            "title": "How do I display optional or required for data object\u2019s sub field in Swagger UI?"
        }, 
        {
            "location": "/faq/#how-do-i-enable-filter-for-specific-endpoint", 
            "text": "register filter to specific servlet whose name is \u201cWeb Application\u201d   FilterRegistration.Dynamic fooFilter = context.addFilter( FooFilter , FOOFilter.class);\nfooFilter.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), true,  Web Application );\nfooFilter.setInitParameter( key ,  val );   register filter to specific endpoint which url matches \u201c/*\u201d   FilterRegistration.Dynamic fooFilter = context.addFilter( FooFilter , FOOFilter.class);\nfooFilter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST) ,true, /* );\nfooFilter.setInitParameter( key ,  val );", 
            "title": "How do I enable filter for specific endpoint?"
        }, 
        {
            "location": "/faq/#how-do-i-define-different-constraint-rules-in-same-data-object-for-different-endpoint", 
            "text": "Use \"validation groups\". Please refer to  Input Validation  for details.", 
            "title": "How do I define different constraint rules in same data object for different endpoint?"
        }, 
        {
            "location": "/faq/#is-it-possible-for-one-data-object-to-extend-another", 
            "text": "In RDL, you can define one type that include another as shown below:    In this RDL snippet, a type Foo is defined. And a type Bar include fields in type Foo, with one additional field  barField .   \ntype Foo struct {\n   String  fooField1;\n   String  fooField2;\n   Int32   fooField3;\n\n}\n\n\ntype Bar Foo {\n    String    barField;\n}  The generated Java classes of these two type doesn't preserve the \"inheritance\" relationship, but all fields from the \"base\" type  Foo  would be included in class  Bar , as shown below:  \npublic final class Foo implements java.io.Serializable {\n\n    private String fooField1;    // (1)\n\n    private String fooField2;    // (2)\n\n    private int fooField3;       // (3)\n\n\n\n    // unrelated code is omitted ...\n}\n\n\n\npublic final class Bar implements java.io.Serializable {\n\n    private String fooField1;    // (1)\n\n    private String fooField2;    // (2)\n\n    private int fooField3;       // (3)\n\n    private String barField;     // (4)\n\n\n    // unrelated code is omitted ...\n}  Note that both classes have 3 common fields ( fooField1 ,  fooField2  and  fooField3  ) however  Bar  doesn't extend from another.", 
            "title": "Is it possible for one data object to extend another?"
        }, 
        {
            "location": "/faq/#how-do-i-define-customized-error-layout", 
            "text": "define your error object in .rdl, and specify status code mapping to\n    your custom data object   sample.rdl  type MyResourceError struct {\n    string errorValue;\n}\n\nresource User GET  /user/{id}  {\n    int32 id;\n\n    expected ACCEPTED;\n    exceptions {\n        ResourceError INTERNAL_SERVER_ERROR;\n        MyResourceError BAD_REQUEST;\n        ResourceError UNAUTHORIZED;\n        ResourceError FORBIDDEN;\n    }\n}   the custom error object and exception mapping of endpoint resources\n    will be generated by rdl generator   SampleResources.java (No need to implemented)  @Path( /sample/v1 )\npublic class SampleResources {\n\n   @GET\n   @Path( /user/{id} )\n   @Produces(MediaType.APPLICATION_JSON)\n   public User getUser(\n       @PathParam( id ) Integer id\n   ) {\n       try {\n           ResourceContext context = _delegate.newResourceContext(_request, _response);\n           User e = _delegate.getUser(context, id);\n           return e;\n       } catch (ResourceException e) {\n           int code = e.getCode();\n           switch (code) {\n           case ResourceException.BAD_REQUEST:\n               throw typedException(code, e, MyResourceError.class);\n           case ResourceException.UNAUTHORIZED:\n               throw typedException(code, e, ResourceError.class);\n           case ResourceException.FORBIDDEN:\n               throw typedException(code, e, ResourceError.class);\n           case ResourceException.INTERNAL_SERVER_ERROR:\n               throw typedException(code, e, ResourceError.class);\n           default:\n               System.err.println( *** Warning: undeclared exception ( +code+ ) for resource getUser );\n               throw typedException(code, e, ResourceError.class);\n           }\n       }\n   }\n}  MyResourceError.java (No need to implemented)  public class MyResourceError {\n\n   public String errorValue;\n\n   public MyResourceError message(String errorValue) {\n       this.errorValue = errorValue;\n       return this;\n   }\n\n   public String toString() {\n       return  {errorValue: \\  + errorValue +  \\ } ;\n   }\n\n}   you only need to throw ResourceException with your custom error\n    object (the code must match with the object you defined in rdl)   public class SampleHandlerImpl implements SampleHandler {\n\n   @Override\n   public User getUser(ResourceContext context, Integer id) {\n       User user = new User();\n       user.setName( dm4 );\n\n       // throw your custom error object depends on your business logic\n       if (id   100) {\n           MyResourceError e = new MyResourceError();\n           e.setErrorValue(id +   is invalid );\n           throw new ResourceException(ResourceException.BAD_REQUEST, e);\n       }\n       return user;\n   }\n\n   ...\n}   the output will be   $ curl -v http://wifi-9-152.tpcity.corp.yahoo.com:8080/api/sample/v1/user/101\n\n* Hostname was NOT found in DNS cache\n*   Trying 10.82.9.152...\n* Connected to wifi-9-152.tpcity.corp.yahoo.com (10.82.9.152) port 8080 (#0)  GET /api/sample/v1/user/101 HTTP/1.1  User-Agent: curl/7.37.1  Host: wifi-9-152.tpcity.corp.yahoo.com:8080  Accept: */*   HTTP/1.1 400 Bad Request  Date: Fri, 04 Sep 2015 02:13:18 GMT  Content-Type: application/json  Content-Length: 34\n* Server Jetty(9.3.0.M2) is not blacklisted  Server: Jetty(9.3.0.M2) \n* Connection #0 to host wifi-9-152.tpcity.corp.yahoo.com left intact\n{ errorValue : 101 is invalid }", 
            "title": "How do I define customized error layout?"
        }, 
        {
            "location": "/faq/#how-to-change-slf4j-logger-binding", 
            "text": "Parsec archetype generate build.gradle default binding implementation to\n    log4j, you could change to logback or any other logger\n    implementation what you like.  Below build.gradle example demo howto change binding to logback   dependencies {\n    // ...\n    compile group: 'ch.qos.logback', name: 'logback-classic', version: '1.1.9'\n    // ...\n}   Detail info could reference  slf4j\n    doc", 
            "title": "How to change slf4j logger binding?"
        }, 
        {
            "location": "/faq/#pending", 
            "text": "", 
            "title": "Pending"
        }, 
        {
            "location": "/faq/#what-does-public-void-authorizestring-action-string-resource-string-trusteddomain-mean-rdl-generated-code-and-how-do-i-use-it", 
            "text": "", 
            "title": "What does \u201cpublic void authorize(String action, String resource, String trustedDomain)\u201d mean (rdl generated code) and how do I use it?"
        }, 
        {
            "location": "/faq/#how-do-i-define-webapp-root-path", 
            "text": "", 
            "title": "How do I define webapp root path?"
        }, 
        {
            "location": "/faq/#how-do-i-define-multipart-in-rdl", 
            "text": "", 
            "title": "How do I define multipart in rdl?"
        }, 
        {
            "location": "/todo/", 
            "text": "Todo\n\n\n\n\nFully support each CD pipeline steps\n\n\nMore Parsec automations to further reduce user steps and manual file\n    creation\n\n\nConfigurations to customize Parsec for each project\n\n\nGenerate test code from RDL", 
            "title": "Todo"
        }, 
        {
            "location": "/todo/#todo", 
            "text": "Fully support each CD pipeline steps  More Parsec automations to further reduce user steps and manual file\n    creation  Configurations to customize Parsec for each project  Generate test code from RDL", 
            "title": "Todo"
        }, 
        {
            "location": "/reference/", 
            "text": "References\n\n\nParsec Performance Test Result\n\n\nServer Machine Spec:\n\n\nSummary:  Dell R410, 2 x Xeon E5620 2.40GHz, 23.6GB / 24GB 1333MHz DDR3, 1 x 500GB SATA\nSystem:       Dell PowerEdge R410 (Dell 01V648), C-2N/24/500, ySPEC 25.0\nProcessors:   2 x Xeon E5620 2.40GHz, 5.86GT QPI (HT enabled, 8 cores, 16 threads) - Gulftown B1, 64-bit, quad-core, 32nm, L3: 12MB\nMemory:       23.6GB / 24GB 1333MHz DDR3 == 6 x 4GB - 4GB PC3-10600 Samsung DDR3-1333 ECC Registered CL9 2Rx8\n\n\n\nJetty setting:\n\n\njava_opts: -Dparsec.conf.env.context=dev.conf\nmaxThreads: 500\n\n\n\nTest Scenario:\n\n\nvalidation filter enable\nconfig file size: 2.6k\n\n\n\n\n\n\n\n\n\nHowever, after turn on the cookie filter, the\nperformance drop dramatically.\n\n\n\n\n\n\n\n\nGit Repositories\n\n\nCore\n\n\n\n\n\n\nparsec\n\n\n\n\n\n\nSupporting Library\n\n\n\n\n\n\nparsec-libraries\n\n\n\n\n\n\nParsec Client Performance Test Result\n\n\nClient Machine Spec:\n\n\nSummary:  Dell R410, 2 x Xeon E5620 2.40GHz, 23.6GB / 24GB 1333MHz DDR3, 1 x 500GB SATA\nSystem:   Dell PowerEdge R410 (Dell 01V648), C-2N/24/500, ySPEC 25.0\nProcessors:   2 x Xeon E5620 2.40GHz, 5.86GT QPI (HT enabled, 8 cores, 16 threads) - Gulftown B1, 64-bit, quad-core, 32nm, L3: 12MB\nMemory:   23.6GB / 24GB 1333MHz DDR3 == 6 x 4GB - 4GB PC3-10600 Samsung DDR3-1333 ECC Registered CL9 2Rx8\n\n\n\nServer Machine Spec:\n\n\nSummary:      Dell R410, 2 x Xeon E5530 2.40GHz, 23.1GB / 24GB 1333MHz DDR3, 1 x 500GB SATA\nSystem:       Dell PowerEdge R410 (Dell 0N051F), C-2N/24/500, ySPEC 25.0\nProcessors:   2 x Xeon E5530 2.40GHz, 5.86GT QPI (HT enabled, 8 cores, 16 threads) - Gainestown D0, 64-bit, quad-core, 45nm, L3: 8MB\nMemory:       23.1GB / 24GB 1333MHz DDR3 == 6 x 4GB - 4GB PC3-10600 Hynix DDR3-1333 ECC Registered CL9 2Rx4\n\n\n\nTest Scenario:\n\n\nNumber of client: 1\nNumber of server: 1\nResponse size: 1k\n\n\n\nNing vs Parsec vs Parsec Status Retry Enabled\n\n\n\n\n\n\n\n\nYhdrRequestFilter\n\n\n\n\n\n\n\n\nHeaderBackpostRequestFilter\n\n\n\n\n\n\n\n\nSequential", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#references", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/reference/#parsec-performance-test-result", 
            "text": "Server Machine Spec:  Summary:  Dell R410, 2 x Xeon E5620 2.40GHz, 23.6GB / 24GB 1333MHz DDR3, 1 x 500GB SATA\nSystem:       Dell PowerEdge R410 (Dell 01V648), C-2N/24/500, ySPEC 25.0\nProcessors:   2 x Xeon E5620 2.40GHz, 5.86GT QPI (HT enabled, 8 cores, 16 threads) - Gulftown B1, 64-bit, quad-core, 32nm, L3: 12MB\nMemory:       23.6GB / 24GB 1333MHz DDR3 == 6 x 4GB - 4GB PC3-10600 Samsung DDR3-1333 ECC Registered CL9 2Rx8  Jetty setting:  java_opts: -Dparsec.conf.env.context=dev.conf\nmaxThreads: 500  Test Scenario:  validation filter enable\nconfig file size: 2.6k     However, after turn on the cookie filter, the\nperformance drop dramatically.", 
            "title": "Parsec Performance Test Result"
        }, 
        {
            "location": "/reference/#git-repositories", 
            "text": "", 
            "title": "Git Repositories"
        }, 
        {
            "location": "/reference/#core", 
            "text": "parsec", 
            "title": "Core"
        }, 
        {
            "location": "/reference/#supporting-library", 
            "text": "parsec-libraries", 
            "title": "Supporting Library"
        }, 
        {
            "location": "/reference/#parsec-client-performance-test-result", 
            "text": "Client Machine Spec:  Summary:  Dell R410, 2 x Xeon E5620 2.40GHz, 23.6GB / 24GB 1333MHz DDR3, 1 x 500GB SATA\nSystem:   Dell PowerEdge R410 (Dell 01V648), C-2N/24/500, ySPEC 25.0\nProcessors:   2 x Xeon E5620 2.40GHz, 5.86GT QPI (HT enabled, 8 cores, 16 threads) - Gulftown B1, 64-bit, quad-core, 32nm, L3: 12MB\nMemory:   23.6GB / 24GB 1333MHz DDR3 == 6 x 4GB - 4GB PC3-10600 Samsung DDR3-1333 ECC Registered CL9 2Rx8  Server Machine Spec:  Summary:      Dell R410, 2 x Xeon E5530 2.40GHz, 23.1GB / 24GB 1333MHz DDR3, 1 x 500GB SATA\nSystem:       Dell PowerEdge R410 (Dell 0N051F), C-2N/24/500, ySPEC 25.0\nProcessors:   2 x Xeon E5530 2.40GHz, 5.86GT QPI (HT enabled, 8 cores, 16 threads) - Gainestown D0, 64-bit, quad-core, 45nm, L3: 8MB\nMemory:       23.1GB / 24GB 1333MHz DDR3 == 6 x 4GB - 4GB PC3-10600 Hynix DDR3-1333 ECC Registered CL9 2Rx4  Test Scenario:  Number of client: 1\nNumber of server: 1\nResponse size: 1k", 
            "title": "Parsec Client Performance Test Result"
        }, 
        {
            "location": "/reference/#ning-vs-parsec-vs-parsec-status-retry-enabled", 
            "text": "", 
            "title": "Ning vs Parsec vs Parsec Status Retry Enabled"
        }, 
        {
            "location": "/reference/#yhdrrequestfilter", 
            "text": "", 
            "title": "YhdrRequestFilter"
        }, 
        {
            "location": "/reference/#headerbackpostrequestfilter", 
            "text": "", 
            "title": "HeaderBackpostRequestFilter"
        }, 
        {
            "location": "/reference/#sequential", 
            "text": "", 
            "title": "Sequential"
        }
    ]
}